{% extends "base.html" %}
{% load static %}

{% block content %}

<h1>Rubik's Cube Visual Solver</h1>
<p>This is a near-optimal Rubik's cube solver based on Kociemba's two stage algorithm.</p>
<p>It provides a solution for most Rubik's cube state within 20 steps, within one second.</p>
<p>We assume your cube has standard color scheme.</p>
<p>For feature request, please email me at my WCA ID @ gmail.com. My WCA ID can be found in <a
        href="https://www.worldcubeassociation.org/persons/2009DENG01" target="_blank">this page</a>.</p>
<p style="font-size: 30px;"><u>Pick a color on the palette and paint the cube below with the color.</u></p>

<div class="palette" id="palette"></div>

{% if output %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    });
</script>
{% endif %}

<form method="POST" onsubmit="prepareSubmit()">
    <table>
        <tbody id="grid-table-body">
            <!-- Rows will be dynamically created -->
        </tbody>
    </table>
    {% csrf_token %}
    <button type="submit" name="action" value="solve" class="big-button">Solve the Cube!</button>
    <button type="submit" name="action" value="reset" id="reset" class="big-button" onclick="resetGrids()">Reset the
        Cube</button>
    <button type="submit" name="action" value="scramble" id="scramble" class="big-button"
        onclick="scrambleGrids()">Auto-scramble the Cube</button>
    {% if output %}
    <div><strong>Solution:</strong> {{ output }}</div>
    {% if clean_alg %}
    <twisty-player style="width: 256px;height: 192px;" experimental-setup-anchor="end" puzzle="3x3x3"
        alg="{{ clean_alg }} {{ rot }}"></twisty-player>
    {% endif %}
    {% else %}
    The solution will appear here.
    {% endif %}
    <!-- Hidden input to hold the full dictionary -->
    <input type="hidden" name="matrix_dict" id="matrix_dict">
</form>


<script>
    const existingGrids = JSON.parse('{{ matrix_dict|default:"{}"|escapejs }}');
    const colors = ['yellow', 'blue', 'orange', 'red', 'green', 'white'];
    let selectedColor = 'white';
    const gridIds = ['U', 'F', 'L', 'R', 'B', 'D'];
    const row = [0, 1, 1, 1, 1, 2];
    const col = [1, 1, 0, 2, 3, 1];

    const paletteEl = document.getElementById('palette');
    const gridTableBody = document.getElementById('grid-table-body');
    const matrixDictInput = document.getElementById('matrix_dict');

    // Initialize data structure
    const allGrids = {};  // { 'a': [ [..], [..], [..] ], 'b': [...] ... }

    const tableRows = [];
    for (let i = 0; i < 3; i++) {
        const tr = document.createElement('tr');
        const cells = [];
        for (let j = 0; j < 4; j++) {
            const td = document.createElement('td');
            tr.appendChild(td);
            cells.push(td);
        }
        gridTableBody.appendChild(tr);
        tableRows.push(cells);
    }

    // Generate palette
    colors.forEach((color, index) => {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = color;
        swatch.onclick = () => {
            selectedColor = color;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');
        };
        paletteEl.appendChild(swatch);
        if (index === 0) {
            selectedColor = color;
            swatch.classList.add('active');
        }
    });

    // Create 6 grids with unique IDs
    gridIds.forEach((gridId, i) => {
        const gridBlock = document.createElement('div');
        gridBlock.className = 'grid-block';

        const label = document.createElement('div');
        label.style.textAlign = 'center';
        label.textContent = `${gridId.toUpperCase()} face`;
        gridBlock.appendChild(label);

        const grid = document.createElement('div');
        grid.className = 'grid';
        grid.dataset.gridId = gridId;
        gridBlock.appendChild(grid);

        // Initialize the 3x3 array for this grid
        allGrids[gridId] = existingGrids[gridId] || Array(3).fill().map(() => Array(3).fill(colors[i]));

        // Create 9 boxes
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
                const box = document.createElement('div');
                box.className = 'box';
                box.dataset.row = row;
                box.dataset.col = col;
                box.dataset.gridId = gridId;
                box.style.backgroundColor = allGrids[gridId][row][col];
                box.onclick = () => {
                    box.style.backgroundColor = selectedColor;
                    allGrids[gridId][row][col] = selectedColor;
                };
                grid.appendChild(box);
            }
        }

        const r = row[i];
        const c = col[i];
        tableRows[r][c].appendChild(gridBlock);
    });

    // On submit, put JSON string in hidden input
    function prepareSubmit() {
        matrixDictInput.value = JSON.stringify(allGrids);
    }

    function resetGrids() {
        // Reset existingGrids and allGrids to empty
        for (const [i, gridId] of gridIds.entries()) {
            // Reset boxes visually
            const boxes = document.querySelectorAll(`.box[data-grid-id="${gridId}"]`);
            boxes.forEach(box => {
                const row = box.dataset.row;
                const col = box.dataset.col;
                box.style.backgroundColor = colors[i];
                allGrids[gridId][row][col] = colors[i];
            });
        }
    }

    function scrambleGrids() {
        for (const [i, gridId] of gridIds.entries()) {
            // Reset boxes visually
            const boxes = document.querySelectorAll(`.box[data-grid-id="${gridId}"]`);
            boxes.forEach(box => {
                const row = box.dataset.row;
                const col = box.dataset.col;
                box.style.backgroundColor = colors[i];
                allGrids[gridId][row][col] = colors[i];
            });
        }
        // Adjust allGrids.
        // Being lazy here, D is not required to scramble a Rubik's cube completely.
        const moves = {
            'U': [
                [['U', 0, 0], ['U', 0, 2], ['U', 2, 2], ['U', 2, 0]],
                [['L', 0, 0], ['B', 0, 0], ['R', 0, 0], ['F', 0, 0]],
                [['L', 0, 2], ['B', 0, 2], ['R', 0, 2], ['F', 0, 2]],
                [['U', 1, 0], ['U', 0, 1], ['U', 1, 2], ['U', 2, 1]],
                [['L', 0, 1], ['B', 0, 1], ['R', 0, 1], ['F', 0, 1]]
            ],
            'L': [
                [['U', 0, 0], ['F', 0, 0], ['D', 0, 0], ['B', 2, 2]],
                [['U', 2, 0], ['F', 2, 0], ['D', 2, 0], ['B', 0, 2]],
                [['L', 0, 0], ['L', 0, 2], ['L', 2, 2], ['L', 2, 0]],
                [['L', 0, 1], ['L', 1, 2], ['L', 2, 1], ['L', 1, 0]],
                [['U', 1, 0], ['F', 1, 0], ['D', 1, 0], ['B', 1, 2]]
            ],
            'F': [
                [['F', 0, 0], ['F', 0, 2], ['F', 2, 2], ['F', 2, 0]],
                [['U', 2, 0], ['R', 0, 0], ['D', 0, 2], ['L', 2, 2]],
                [['L', 0, 2], ['U', 2, 2], ['R', 2, 0], ['D', 0, 0]],
                [['U', 2, 1], ['R', 1, 0], ['D', 0, 1], ['L', 1, 2]],
                [['F', 0, 1], ['F', 1, 2], ['F', 2, 1], ['F', 1, 0]]
            ],
            'R': [
                [['R', 0, 0], ['R', 0, 2], ['R', 2, 2], ['R', 2, 0]],
                [['U', 2, 2], ['B', 0, 0], ['D', 2, 2], ['F', 2, 2]],
                [['U', 0, 2], ['B', 2, 0], ['D', 0, 2], ['F', 0, 2]],
                [['R', 0, 1], ['R', 1, 2], ['R', 2, 1], ['R', 1, 0]],
                [['U', 1, 2], ['B', 1, 0], ['D', 1, 2], ['F', 1, 2]]
            ],
            'B': [
                [['B', 0, 0], ['B', 0, 2], ['B', 2, 2], ['B', 2, 0]],
                [['U', 0, 0], ['L', 2, 0], ['D', 2, 2], ['R', 0, 2]],
                [['U', 0, 2], ['L', 0, 0], ['D', 2, 0], ['R', 2, 2]],
                [['B', 0, 1], ['B', 1, 2], ['B', 2, 1], ['B', 1, 0]],
                [['U', 0, 1], ['L', 1, 0], ['D', 2, 1], ['R', 1, 2]]
            ]
        };
        const keys = Object.keys(moves);
        let scrambleString = "";
        const numSteps = 30;
        for (let step = 0; step < numSteps; step++) {
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            const n = [1, 2, 3][Math.floor(Math.random() * 3)];
            if (step > 0) {
                scrambleString += " ";
            }
            scrambleString += randomKey + { 1: '', 2: '2', 3: "'" }[n];
            for (let i = 0; i < n; i++) {
                // Apply a move.
                let copiedGrids = JSON.parse(JSON.stringify(allGrids));
                for (const moveCycle of moves[randomKey]) {
                    for (let j = 0; j < moveCycle.length; j++) {
                        const from = moveCycle[j];
                        const target = moveCycle[(j + 1) % moveCycle.length];
                        copiedGrids[target[0]][target[1]][target[2]] = allGrids[from[0]][from[1]][from[2]];
                    }
                }
                for (const moveCycle of moves[randomKey]) {
                    for (let j = 0; j < moveCycle.length; j++) {
                        const from = moveCycle[j];
                        allGrids[from[0]][from[1]][from[2]] = copiedGrids[from[0]][from[1]][from[2]];
                    }
                }
            }
        }
        console.log(scrambleString);
        // Update box color.
        for (const [i, gridId] of gridIds.entries()) {
            // Reset boxes visually
            const boxes = document.querySelectorAll(`.box[data-grid-id="${gridId}"]`);
            boxes.forEach(box => {
                const row = box.dataset.row;
                const col = box.dataset.col;
                box.style.backgroundColor = allGrids[gridId][row][col];
            });
        }
    }
</script>


{% endblock content %}