{% extends "base.html" %}
{% load static %}

{% block content %}

<h1>Adaptive EG Trainer</h1>

<div id="trainer-section">
    <div style="margin-bottom: 10px;">
        <h2>Current Case: <span id="current-case-name"></span></h2>
        <div id="overall-stats-display" style="font-size: 0.9em; color: #333; margin-top: 5px; margin-bottom:15px;">
            </div>
    </div>
    <div id="case-visualization" style="text-align: center; margin-bottom: 10px;">
        </div>
    <div style="text-align: center; margin-bottom: 10px;">
        <button id="reveal-alg-btn">Reveal Algorithm</button>
    </div>
    <div id="algorithm-details" style="text-align: center; margin-bottom: 20px; display: none;">
        <p><strong>Algorithm:</strong> <span id="current-alg"></span></p>
        </div>
    <div style="text-align: center; margin-bottom: 5px;"> 
        <button id="correct-btn">Correct</button>
        <button id="incorrect-btn">Incorrect</button>
    </div>
    <div id="shortcut-hint" style="text-align: center; font-size: 0.8em; color: #555; margin-bottom: 20px;">
        (Shortcut: Spacebar for Correct, 'X' for Incorrect)
    </div>
    <div style="text-align: center; margin-bottom: 20px;">
        <button id="reset-stats-btn">Reset Stats</button>
    </div>
</div>

<hr>

<div>
    <h2>Case Statistics (Failures)</h2>
    <button id="show-ranked-cases-btn">Show Touched Failure Cases (Worst First)</button>
    <div id="ranked-cases-container" style="margin-top: 10px;">
        </div>
</div>

<script id="table-data-json-script" type="application/json">
    {{ table_data_json|safe }}
</script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const algorithmsDataElement = document.getElementById('table-data-json-script');
    let ALGORITHMS_DATA = [];
    if (algorithmsDataElement && algorithmsDataElement.textContent) {
        try {
            ALGORITHMS_DATA = JSON.parse(algorithmsDataElement.textContent);
        } catch (e) {
            console.error("Error parsing JSON data:", e);
            document.getElementById('current-case-name').textContent = "Error loading algorithm data.";
            return; 
        }
    } else {
        console.error("Algorithm data script tag not found or empty.");
        document.getElementById('current-case-name').textContent = "Algorithm data not found.";
        return; 
    }

    const caseVisualizationDiv = document.getElementById('case-visualization');
    const currentCaseNameSpan = document.getElementById('current-case-name');
    const overallStatsDisplayDiv = document.getElementById('overall-stats-display'); 
    const revealAlgBtn = document.getElementById('reveal-alg-btn');
    const algorithmDetailsDiv = document.getElementById('algorithm-details');
    const currentAlgSpan = document.getElementById('current-alg');
    const correctBtn = document.getElementById('correct-btn');
    const incorrectBtn = document.getElementById('incorrect-btn');
    const resetStatsBtn = document.getElementById('reset-stats-btn');
    const showRankedCasesBtn = document.getElementById('show-ranked-cases-btn');
    const rankedCasesContainer = document.getElementById('ranked-cases-container');

    let currentCase = null;
    let stats = {}; 

    const STATS_STORAGE_KEY = 'egTrainerStats_CLL'; 

    function loadStats() {
        const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
        if (storedStats) {
            try {
                stats = JSON.parse(storedStats);
            } catch (e) {
                console.error("Error parsing stats from localStorage:", e);
                stats = {}; 
            }
        }
        ALGORITHMS_DATA.forEach(alg => {
            if (!stats[alg.Case]) { 
                stats[alg.Case] = { pos: 0, neg: 0 };
            }
        });
        updateOverallStatsDisplay();
    }

    function saveStats() {
        localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(stats));
        updateOverallStatsDisplay();
    }

    function resetAllStats() {
        if (window.confirm("Are you sure you want to reset all your statistics? This cannot be undone.")) {
            ALGORITHMS_DATA.forEach(alg => {
                stats[alg.Case] = { pos: 0, neg: 0 };
            });
            saveStats();
            console.log("Statistics have been reset."); 
            selectAndDisplayNewCase();
            if (rankedCasesContainer.innerHTML !== '') {
                 displayRankedCases();
            }
        }
    }

    function displayTwistyPlayer(parentElement, algSetup) {
        parentElement.innerHTML = '';
        const player = document.createElement('twisty-player');
        player.setAttribute('style', 'width: 256px; height: 192px; min-width: 256px; min-height: 192px;');
        player.setAttribute('experimental-setup-anchor', 'end');
        player.setAttribute('puzzle', '2x2x2');
        player.setAttribute('background', 'none');
        player.setAttribute('control-panel', 'none');
        player.setAttribute('alg', `${algSetup} y z2`);
        parentElement.appendChild(player);
    }
    
    function updateOverallStatsDisplay() {
        if (!ALGORITHMS_DATA || ALGORITHMS_DATA.length === 0) {
            overallStatsDisplayDiv.innerHTML = "No algorithm data loaded.";
            return;
        }
        let totalPractices = 0;
        let totalCorrect = 0;
        let touchedCasesCount = 0;
        let correctCasesCount = 0;
        const totalCasesN = ALGORITHMS_DATA.length;

        for (const caseName in stats) {
            if (stats.hasOwnProperty(caseName) && ALGORITHMS_DATA.some(alg => alg.Case === caseName)) {
                const caseStat = stats[caseName];
                const attemptsInCase = caseStat.pos + caseStat.neg;
                totalPractices += attemptsInCase;
                totalCorrect += caseStat.pos;

                if (attemptsInCase > 0) {
                    touchedCasesCount++;
                }
                if (caseStat.pos > 0) {
                    correctCasesCount++;
                }
            }
        }

        const correctRate = totalPractices > 0 ? (totalCorrect / totalPractices) * 100 : 0;

        overallStatsDisplayDiv.innerHTML = `
            Total Practices: ${totalPractices} | 
            Correct: ${totalCorrect} (${correctRate.toFixed(1)}%) | 
            Touched Cases: ${touchedCasesCount}/${totalCasesN} | 
            Cases with Correct: ${correctCasesCount}/${totalCasesN}
        `;
    }

    function selectAndDisplayNewCase() {
        if (ALGORITHMS_DATA.length === 0) {
            currentCaseNameSpan.innerHTML = "No algorithms loaded.";
            overallStatsDisplayDiv.innerHTML = ""; 
            correctBtn.disabled = true;
            incorrectBtn.disabled = true;
            revealAlgBtn.disabled = true;
            return;
        }

        let weightedCases = [];
        let totalWeight = 0;

        ALGORITHMS_DATA.forEach(alg => {
            const caseStat = stats[alg.Case] || { pos: 0, neg: 0 };
            
            // --- MODIFIED SAMPLING AND WEIGHTING LOGIC ---
            // If a case has ANY correct attempts (pos > 0), do not sample it for practice.
            if (caseStat.pos > 0) {
                return; // Skip this algorithm for weighted selection
            }

            // At this point, caseStat.pos is 0 (never marked correct)
            let weight;
            if (caseStat.neg > 0) {
                // Aggressively high weight for error cases (that have never been marked correct)
                // Base is 10 * number of errors, plus a base of 5.
                weight = (caseStat.neg * 10) + 5; 
            } else {
                // New, untouched cases (pos=0, neg=0)
                weight = 2; // Base weight for new cases
            }
            // Ensure a minimum weight 
            weight = Math.max(0.01, weight); 
            // --- END OF MODIFIED SAMPLING AND WEIGHTING LOGIC ---

            weightedCases.push({ caseData: alg, weight: weight });
            totalWeight += weight;
        });
        
        // Handle the case where all algorithms have been marked correct at least once
        if (weightedCases.length === 0) {
            currentCaseNameSpan.innerHTML = "All available cases have at least one correct attempt!<br>Reset stats or review failures to continue practice.";
            overallStatsDisplayDiv.innerHTML = "Practice complete based on current rules. No new cases to sample.";
            correctBtn.disabled = true;
            incorrectBtn.disabled = true;
            revealAlgBtn.disabled = true;
            caseVisualizationDiv.innerHTML = ''; // Clear visualization
            currentCase = null; 
            return;
        }
        
        // Fallback if totalWeight is 0 but weightedCases is not empty (shouldn't happen with Math.max(0.01))
        if (totalWeight <= 0 && weightedCases.length > 0) { 
             weightedCases.forEach(wc => { // Re-assign uniform weight if something went wrong
                wc.weight = 1;
                totalWeight +=1;
            });
        }


        let randomNum = Math.random() * totalWeight;
        let selectedAlg = null;
        for (let i = 0; i < weightedCases.length; i++) {
            randomNum -= weightedCases[i].weight;
            if (randomNum <= 0) {
                selectedAlg = weightedCases[i].caseData;
                break;
            }
        }
        // Fallback if loop finishes without selecting (e.g., due to floating point issues with totalWeight)
        if (!selectedAlg && weightedCases.length > 0) { 
            selectedAlg = weightedCases[Math.floor(Math.random() * weightedCases.length)].caseData;
        }
        
        currentCase = selectedAlg;

        currentCaseNameSpan.innerHTML = `${currentCase.Case}<br><span style="font-size: 0.8em; color: #666;">${currentCase.scramble || currentCase.viz}</span>`; 
        displayTwistyPlayer(caseVisualizationDiv, currentCase.viz); 
        
        algorithmDetailsDiv.style.display = 'none';
        revealAlgBtn.disabled = false;
        correctBtn.disabled = false; 
        incorrectBtn.disabled = false; 
        updateOverallStatsDisplay(); 
    }

    revealAlgBtn.addEventListener('click', () => {
        if (!currentCase) return;
        currentAlgSpan.textContent = currentCase.alg; 
        algorithmDetailsDiv.style.display = 'block';
        revealAlgBtn.disabled = true;
    });

    function handleAttempt(isCorrect) {
        if (!currentCase) return;
        const caseStat = stats[currentCase.Case];
        if (isCorrect) {
            caseStat.pos++;
        } else {
            caseStat.neg++;
        }
        saveStats(); 
        selectAndDisplayNewCase(); 
    }

    correctBtn.addEventListener('click', () => handleAttempt(true));
    incorrectBtn.addEventListener('click', () => handleAttempt(false));
    resetStatsBtn.addEventListener('click', resetAllStats);
    showRankedCasesBtn.addEventListener('click', displayRankedCases);

    document.addEventListener('keydown', function(event) {
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
            return; 
        }

        if (event.key === ' ' || event.code === 'Space') {
            event.preventDefault(); 
            if (!correctBtn.disabled) { 
                handleAttempt(true);
            }
        } else if (event.key.toLowerCase() === 'x') {
            if (!incorrectBtn.disabled) { 
                handleAttempt(false);
            }
        }
    });

    function displayRankedCases() {
        rankedCasesContainer.innerHTML = ''; 
        const casesWithStats = ALGORITHMS_DATA.map(alg => {
            const caseStat = stats[alg.Case] || { pos: 0, neg: 0 };
            const totalAttempts = caseStat.pos + caseStat.neg;
            let successRate = 0; 
            if (totalAttempts > 0) {
                successRate = (caseStat.pos / totalAttempts) * 100;
            }
            return { ...alg, ...caseStat, totalAttempts, successRate };
        });

        // Filter for cases with errors (neg > 0)
        // This means cases with (pos > 0 and neg > 0) will still be shown here.
        const ranked = casesWithStats
            .filter(item => item.neg > 0) 
            .sort((a, b) => {
                if (a.successRate !== b.successRate) return a.successRate - b.successRate;
                if (a.neg !== b.neg) return b.neg - a.neg;
                if (a.pos !== b.pos) return a.pos - b.pos;
                return a.Case.localeCompare(b.Case);
            });

        if (ranked.length === 0) {
            rankedCasesContainer.textContent = "No failure cases to display (no incorrect attempts recorded yet).";
            return;
        }

        const ul = document.createElement('ul');
        ul.style.listStyleType = 'none';
        ul.style.padding = '0';
        ranked.forEach(item => {
            const li = document.createElement('li');
            li.style.marginBottom = '15px';
            li.style.padding = '10px';
            li.style.border = '1px solid #eee';
            const name = document.createElement('strong');
            name.textContent = `${item.Case}`;
            li.appendChild(name);

            const statsText = document.createElement('p');
            statsText.style.margin = '5px 0';
            statsText.textContent = `Success: ${item.successRate.toFixed(1)}% (${item.pos} correct, ${item.neg} incorrect, ${item.totalAttempts} total)`;
            li.appendChild(statsText);
            
            const algText = document.createElement('p');
            algText.style.margin = '5px 0';
            algText.style.fontSize = '0.9em';
            algText.textContent = `Alg: ${item.alg}`; 
            li.appendChild(algText);

            const scrambleText = document.createElement('p');
            scrambleText.style.margin = '5px 0';
            scrambleText.style.fontSize = '0.9em';
            scrambleText.style.color = '#555'; 
            scrambleText.textContent = `Scramble: ${item.scramble || 'N/A'}`; 
            li.appendChild(scrambleText);

            const vizButton = document.createElement('button');
            vizButton.textContent = 'Show Visualization';
            vizButton.style.marginRight = '10px';
            vizButton.style.fontSize = '0.9em';
            
            const vizContainer = document.createElement('div');
            vizContainer.style.marginTop = '5px';
            vizContainer.style.display = 'none';
            vizButton.onclick = () => {
                if (vizContainer.style.display === 'none') {
                    displayTwistyPlayer(vizContainer, item.viz); 
                    vizContainer.style.display = 'block';
                    vizButton.textContent = 'Hide Visualization';
                } else {
                    vizContainer.innerHTML = '';
                    vizContainer.style.display = 'none';
                    vizButton.textContent = 'Show Visualization';
                }
            };
            li.appendChild(vizButton);
            li.appendChild(vizContainer);
            ul.appendChild(li);
        });
        rankedCasesContainer.appendChild(ul);
    }

    loadStats(); 
    selectAndDisplayNewCase(); 
});
</script>

<style>
    #trainer-section button,
    #show-ranked-cases-btn {
        padding: 8px 15px;
        margin: 5px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f0f0f0;
    }

    #trainer-section button:hover,
    #show-ranked-cases-btn:hover {
        background-color: #e0e0e0;
    }

    #trainer-section button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
    }

    #ranked-cases-container ul {
        padding-left: 0;
    }

    #ranked-cases-container li {
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        margin-bottom: 10px;
        padding: 10px;
        border-radius: 4px;
    }
    #overall-stats-display { 
        padding: 5px;
        border-bottom: 1px solid #eee; 
    }
</style>

{% endblock content %}
